 import os, io, time, math, logging from pathlib import Path from typing import Dict, Any, List, Tuple from flask import Flask, request, jsonify, abort from PIL import Image import numpy as np import cv2 # ===== LINE SDK ===== from linebot import LineBotApi, WebhookHandler from linebot.exceptions import InvalidSignatureError from linebot.models import ( MessageEvent, TextMessage, ImageMessage, TextSendMessage, FollowEvent ) # ===== Optional ML ===== try: import joblib except Exception: joblib = None try: import xgboost as xgb except Exception: xgb = None try: import lightgbm as lgb except Exception: lgb = None try: from hmmlearn.hmm import MultinomialHMM except Exception: MultinomialHMM = None app = Flask(__name__) # ---------- Logging ---------- logging.basicConfig(level=logging.INFO) logger = logging.getLogger("bgs-bot") # ---------- ENV ---------- LINE_CHANNEL_ACCESS_TOKEN = os.getenv("LINE_CHANNEL_ACCESS_TOKEN", "") LINE_CHANNEL_SECRET = os.getenv("LINE_CHANNEL_SECRET", "") line_bot_api = LineBotApi(LINE_CHANNEL_ACCESS_TOKEN) if LINE_CHANNEL_ACCESS_TOKEN else None line_handler = WebhookHandler(LINE_CHANNEL_SECRET) if LINE_CHANNEL_SECRET else None # --- Vision tuning (å¯ç”±ç’°å¢ƒè®Šæ•¸èª¿) --- DEBUG_VISION = os.getenv("DEBUG_VISION", "0") == "1" HSV = { "RED1_LOW": (int(os.getenv("HSV_RED1_H_LOW", "0")), int(os.getenv("HSV_RED1_S_LOW", "50")), int(os.getenv("HSV_RED1_V_LOW", "50"))), "RED1_HIGH": (int(os.getenv("HSV_RED1_H_HIGH", "12")), int(os.getenv("HSV_RED1_S_HIGH", "255")),int(os.getenv("HSV_RED1_V_HIGH", "255"))), "RED2_LOW": (int(os.getenv("HSV_RED2_H_LOW", "170")),int(os.getenv("HSV_RED2_S_LOW", "50")), int(os.getenv("HSV_RED2_V_LOW", "50"))), "RED2_HIGH": (int(os.getenv("HSV_RED2_H_HIGH", "180")),int(os.getenv("HSV_RED2_S_HIGH", "255")),int(os.getenv("HSV_RED2_V_HIGH", "255"))), "BLUE_LOW": (int(os.getenv("HSV_BLUE_H_LOW", "90")), int(os.getenv("HSV_BLUE_S_LOW", "50")), int(os.getenv("HSV_BLUE_V_LOW", "50"))), "BLUE_HIGH": (int(os.getenv("HSV_BLUE_H_HIGH", "135")),int(os.getenv("HSV_BLUE_S_HIGH", "255")),int(os.getenv("HSV_BLUE_V_HIGH", "255"))), "GREEN_LOW": (int(os.getenv("HSV_GREEN_H_LOW", "40")), int(os.getenv("HSV_GREEN_S_LOW", "40")), int(os.getenv("HSV_GREEN_V_LOW", "40"))), "GREEN_HIGH":(int(os.getenv("HSV_GREEN_H_HIGH","85")), int(os.getenv("HSV_GREEN_S_HIGH","255")),int(os.getenv("HSV_GREEN_V_HIGH","255"))), } HOUGH_MIN_LEN_RATIO = float(os.getenv("HOUGH_MIN_LEN_RATIO", "0.45")) # ROI å¯¬åº¦æ¯”ä¾‹ HOUGH_GAP = int(os.getenv("HOUGH_GAP", "6")) CANNY1 = int(os.getenv("CANNY1", "60")) CANNY2 = int(os.getenv("CANNY2", "180")) # ---------- User session: æ˜¯å¦é€²å…¥åˆ†ææ¨¡å¼ ---------- user_mode: Dict[str, bool] = {} # user_id -> True/False # ---------- æ¨¡å‹è¼‰å…¥ ---------- MODELS_DIR = Path("models") SCALER_PATH = MODELS_DIR / "scaler.pkl" XGB_PKL = MODELS_DIR / "xgb_model.pkl" XGB_JSON = MODELS_DIR / "xgb_model.json" XGB_UBJ = MODELS_DIR / "xgb_model.ubj" LGBM_PKL = MODELS_DIR / "lgbm_model.pkl" LGBM_TXT = MODELS_DIR / "lgbm_model.txt" LGBM_JSON = MODELS_DIR / "lgbm_model.json" HMM_PKL = MODELS_DIR / "hmm_model.pkl" model_bundle: Dict[str, Any] = {"loaded": False, "note": "no model"} def _safe_exists(p: Path) -> bool: try: return p.exists() except Exception: return False def load_models(): global model_bundle bundle: Dict[str, Any] = {} try: if joblib and _safe_exists(SCALER_PATH): bundle["scaler"] = joblib.load(SCALER_PATH) if xgb: if _safe_exists(XGB_PKL) and joblib: bundle["xgb_sklearn"] = joblib.load(XGB_PKL) elif _safe_exists(XGB_JSON): bst = xgb.Booster(); bst.load_model(str(XGB_JSON)) bundle["xgb_booster"] = bst elif _safe_exists(XGB_UBJ): bst = xgb.Booster(); bst.load_model(str(XGB_UBJ)) bundle["xgb_booster"] = bst if lgb: if _safe_exists(LGBM_PKL) and joblib: bundle["lgbm_sklearn"] = joblib.load(LGBM_PKL) elif _safe_exists(LGBM_TXT): bundle["lgbm_booster"] = lgb.Booster(model_file=str(LGBM_TXT)) elif _safe_exists(LGBM_JSON): booster = lgb.Booster(model_str=LGBM_JSON.read_text(encoding="utf-8")) bundle["lgbm_booster"] = booster if MultinomialHMM and joblib and _safe_exists(HMM_PKL): hmm = joblib.load(HMM_PKL) if hasattr(hmm, "n_components") and hmm.n_components == 3: bundle["hmm"] = hmm bundle["loaded"] = any(k in bundle for k in ( "xgb_sklearn", "xgb_booster", "lgbm_sklearn", "lgbm_booster", "hmm" )) bundle["note"] = "at least one model loaded" if bundle["loaded"] else "no model file found" model_bundle = bundle logger.info(f"[models] loaded={bundle['loaded']} note={bundle['note']}") except Exception as e: model_bundle = {"loaded": False, "note": f"load error: {e}"} logger.exception(f"[models] load error: {e}") load_models() # ========================================================= # åœ–åƒâ†’åºåˆ—ï¼ˆæ”¯æ´ï¼šç´…=èŠ, è—=é–’ï¼›ç´…/è—åœˆå…§"æ©«ç·š"=å’Œï¼‰ # ========================================================= IDX = {"B":0,"P":1,"T":2} def _has_horizontal_line(roi_bgr: np.ndarray) -> bool: """åœ¨ç´…/è—åœˆ ROI å…§æª¢æ¸¬æ˜¯å¦æœ‰è¿‘æ°´å¹³ç›´ç·šï¼ˆåˆ¤å®šç‚ºå’Œå±€ï¼‰ã€‚""" if roi_bgr is None or roi_bgr.size == 0: return False # å°æ¯”å¢å¼· + å»å™ª lab = cv2.cvtColor(roi_bgr, cv2.COLOR_BGR2LAB) l, a, b = cv2.split(lab) clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(4,4)) l = clahe.apply(l) lab = cv2.merge([l, a, b]) enh = cv2.cvtColor(lab, cv2.COLOR_LAB2BGR) gray = cv2.cvtColor(enh, cv2.COLOR_BGR2GRAY) gray = cv2.medianBlur(gray, 3) # äºŒå€¼åŒ– + é‚Šç·£ thr = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, 11, 2) edges = cv2.Canny(thr, CANNY1, CANNY2) h, w = edges.shape[:2] min_len = max(int(w * HOUGH_MIN_LEN_RATIO), 12) lines = cv2.HoughLinesP(edges, 1, np.pi/180, threshold=20, minLineLength=min_len, maxLineGap=HOUGH_GAP) if lines is None: return False # è¿‘æ°´å¹³ï¼š|dy| å°æ–¼ 12% é«˜åº¦ï¼ˆæ›´åš´æ ¼ï¼‰ for x1, y1, x2, y2 in lines[:, 0, :]: if abs(y2 - y1) <= max(2, int(h * 0.12)): return True return False def extract_sequence_from_image(img_bytes: bytes) -> List[str]: """ å›å‚³åºåˆ—ï¼ˆæœ€å¤š 240 æ‰‹ï¼‰ï¼š'B', 'P', 'T' è¦å‰‡ï¼š - ç´…=èŠ(B), è—=é–’(P) - è‹¥ç´…/è—åœˆ ROI å…§åµæ¸¬åˆ°æ°´å¹³ç›´ç·š â†’ è¦–ç‚ºå’Œ(T) - ç¶ è‰²ï¼ˆè‹¥æœ‰ï¼‰ä¹Ÿç•¶ T """ try: img = Image.open(io.BytesIO(img_bytes)).convert("RGB") img = np.array(img) img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR) # è¦ä¸€åŒ–ï¼ˆå°åœ–æ”¾å¤§ï¼Œé¿å…åœˆå¤ªå°ï¼‰ h0, w0 = img.shape[:2] target = 1400.0 scale = target / max(h0, w0) if max(h0, w0) < target else 1.0 if scale > 1.0: img = cv2.resize(img, (int(w0*scale), int(h0*scale)), interpolation=cv2.INTER_CUBIC) # é™å™ª + é¡è‰²ç©ºé–“ blur = cv2.GaussianBlur(img, (3,3), 0) hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV) # é¡è‰²é®ç½©ï¼ˆå¯ç”±ç’°å¢ƒè®Šæ•¸èª¿ï¼‰ red1 = cv2.inRange(hsv, HSV["RED1_LOW"], HSV["RED1_HIGH"]) red2 = cv2.inRange(hsv, HSV["RED2_LOW"], HSV["RED2_HIGH"]) red = cv2.bitwise_or(red1, red2) blue = cv2.inRange(hsv, HSV["BLUE_LOW"], HSV["BLUE_HIGH"]) green= cv2.inRange(hsv, HSV["GREEN_LOW"], HSV["GREEN_HIGH"]) # å½¢æ…‹å­¸ï¼šå…ˆ close è£œæ´ï¼Œå† open å»é›œè¨Š kernel3 = np.ones((3,3), np.uint8) def clean(m): m = cv2.morphologyEx(m, cv2.MORPH_CLOSE, kernel3, iterations=1) m = cv2.morphologyEx(m, cv2.MORPH_OPEN, kernel3, iterations=1) return m red, blue, green = clean(red), clean(blue), clean(green) # ä»¥ connected components å–å¾—ç©©å®š blob def cc_blobs(mask, label): n, labels, stats, centroids = cv2.connectedComponentsWithStats(mask, connectivity=8) items = [] # çµ±è¨ˆå¹³å‡é¢ç©ä¾†è‡ªé©æ‡‰éå°/éå¤§æ¿¾é™¤ areas = [stats[i, cv2.CC_STAT_AREA] for i in range(1, n)] area_med = np.median(areas) if areas else 0 min_area = max(80, int(area_med * 0.35)) # è‡ªé©æ‡‰é–€æª» max_area = int(area_med * 8) if area_med > 0 else 999999 for i in range(1, n): x, y, w, h, a = stats[i, 0], stats[i, 1], stats[i, 2], stats[i, 3], stats[i, 4] if a < min_area or a > max_area: continue # åœ“åº¦/é•·å¯¬æ¯”éæ¿¾ï¼Œé¿å…é•·æ¢å™ªè² aspect = w / (h + 1e-6) if not (0.5 <= aspect <= 2.0): continue c = (labels == i).astype(np.uint8) * 255 cnts, _ = cv2.findContours(c, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) if not cnts: continue cnt = max(cnts, key=cv2.contourArea) per = cv2.arcLength(cnt, True) area = cv2.contourArea(cnt) if per <= 0 or area <= 0: continue circularity = 4 * math.pi * area / (per * per) if circularity < 0.3: # å¤ªä¸åœ“çš„éæ¿¾ continue cx = x + w / 2.0 items.append((x, y, w, h, cx, label)) return items items = [] items += cc_blobs(red, "B") items += cc_blobs(blue, "P") items += cc_blobs(green,"T") # è‹¥å¹³å°ç”¨ç¶ è‰²å–®ç¨æ¨™å’Œ if not items: return [] # ä¾ x ä¸­å¿ƒæ’åº â†’ å¤§è·¯ç”±å·¦è‡³å³ items.sort(key=lambda z: z[4]) # å‹•æ…‹é–“è·ï¼šç”¨ blob å¯¬åº¦ä¸­ä½æ•¸ widths = [w for _,_,w,_,_,_ in items] med_w = np.median(widths) if widths else 12 min_gap = max(med_w * 0.6, 10) seq: List[str] = [] last_cx = -1e9 for x,y,w0,h0,cx,label in items: if abs(cx - last_cx) < min_gap: continue if label in {"B","P"}: # å–è¼ƒå°çš„å…§éƒ¨ ROI æª¢ç·šï¼Œé¿å…é‚Šç•Œå¹²æ“¾ pad_x = max(2, int(w0 * 0.18)) pad_y = max(2, int(h0 * 0.28)) x1 = max(0, int(x + pad_x)); x2 = min(img.shape[1], int(x + w0 - pad_x)) y1 = max(0, int(y + pad_y)); y2 = min(img.shape[0], int(y + h0 - pad_y)) roi = img[y1:y2, x1:x2] if _has_horizontal_line(roi): seq.append("T") # æ©«ç·šè¦–ç‚ºå’Œ else: seq.append(label) else: # ç¶ è‰²ï¼ˆè‹¥å¹³å°æœ‰ï¼‰ç›´æ¥è¦–ç‚ºå’Œ seq.append("T") last_cx = cx if DEBUG_VISION: logger.info(f"[VISION] items={len(items)} widths_med={med_w:.1f} min_gap={min_gap:.1f} seq_len={len(seq)}") return seq[-240:] except Exception as e: if DEBUG_VISION: logger.exception(f"[VISION][ERR] {e}") return [] # ========================================================= # ç‰¹å¾µå·¥ç¨‹ & æ¨¡å‹æ¨ç† & è¦å‰‡å›é€€ # ========================================================= def _streak_tail(seq: List[str]) -> int: if not seq: return 0 t, c = seq[-1], 1 for i in range(len(seq)-2, -1, -1): if seq[i]==t: c+=1 else: break return c def _transitions(seq: List[str]) -> np.ndarray: m = np.zeros((3,3), dtype=np.float32) for a,b in zip(seq, seq[1:]): if a in IDX and b in IDX: m[IDX[a], IDX[b]] += 1 if m.sum()>0: m = m/(m.sum()+1e-6) return m.flatten() def _ratio_lastN(seq: List[str], N: int) -> Tuple[float,float,float]: s = seq[-N:] if len(seq)>=N else seq if not s: return (0.33,0.33,0.34) n = len(s); return (s.count("B")/n, s.count("P")/n, s.count("T")/n) def build_features(seq: List[str]) -> np.ndarray: n = len(seq) pb, pp, pt = _ratio_lastN(seq, n) b10,p10,t10 = _ratio_lastN(seq,10) b20,p20,t20 = _ratio_lastN(seq,20) streak = _streak_tail(seq) last = np.zeros(3); last[IDX[seq[-1]]] = 1.0 trans = _transitions(seq) entropy = 0.0 for v in [pb,pp,pt]: if v>1e-9: entropy -= v*math.log(v+1e-9) feat = np.array([n,pb,pp,pt,b10,p10,t10,b20,p20,t20,streak,entropy,*last,*trans], dtype=np.float32).reshape(1,-1) return feat def _normalize(p: Dict[str,float]) -> Dict[str,float]: s = p["banker"]+p["player"]+p["tie"] if s<=0: return {"banker":0.34,"player":0.34,"tie":0.32} return {k: round(v/s,4) for k,v in p.items()} def _proba_from_xgb(feat: np.ndarray) -> Dict[str,float] | None: if "xgb_sklearn" in model_bundle: proba = model_bundle["xgb_sklearn"].predict_proba(feat)[0] return {"banker": float(proba[IDX["B"]]), "player": float(proba[IDX["P"]]), "tie": float(proba[IDX["T"]])} if "xgb_booster" in model_bundle and xgb: d = xgb.DMatrix(feat); proba = model_bundle["xgb_booster"].predict(d)[0] if len(proba)==3: return {"banker": float(proba[0]), "player": float(proba[1]), "tie": float(proba[2])} return None def _proba_from_lgb(feat: np.ndarray) -> Dict[str,float] | None: if "lgbm_sklearn" in model_bundle: proba = model_bundle["lgbm_sklearn"].predict_proba(feat)[0] return {"banker": float(proba[IDX["B"]]), "player": float(proba[IDX["P"]]), "tie": float(proba[IDX["T"]])} if "lgbm_booster" in model_bundle and lgb: proba = model_bundle["lgbm_booster"].predict(feat)[0] if isinstance(proba,(list,np.ndarray)) and len(proba)==3: return {"banker": float(proba[0]), "player": float(proba[1]), "tie": float(proba[2])} return None def _proba_from_hmm(seq: List[str]) -> Dict[str,float] | None: hmm = model_bundle.get("hmm") if not hmm or not seq: return None sym = {"B":0,"P":1,"T":2} base = np.array([[sym[s]] for s in seq], dtype=np.int32) scores=[] for cand in ["B","P","T"]: test = np.vstack([base, [[sym[cand]]]]) try: logp = hmm.score(test, lengths=[len(test)]) except Exception: logp = -1e9 scores.append(logp) m = max(scores); exps = np.exp(np.array(scores)-m) prob = exps/(exps.sum()+1e-12) return {"banker": float(prob[0]), "player": float(prob[1]), "tie": float(prob[2])} def predict_with_models(seq: List[str]) -> Dict[str,float] | None: feat = build_features(seq) if "scaler" in model_bundle: feat = model_bundle["scaler"].transform(feat) votes=[] p=_proba_from_xgb(feat); votes.append(p) if p else None p=_proba_from_lgb(feat); votes.append(p) if p else None p=_proba_from_hmm(seq); votes.append(p) if p else None if not votes: return None avg={"banker":0.0,"player":0.0,"tie":0.0} for v in votes: for k in avg: avg[k]+=v[k] for k in avg: avg[k]/=len(votes) return _normalize(avg) def predict_probs_from_seq_rule(seq: List[str]) -> Dict[str,float]: n=len(seq) if n==0: return {"banker":0.33,"player":0.33,"tie":0.34} pb = seq.count("B")/n pp = seq.count("P")/n pt = max(0.02, seq.count("T")/n*0.6) # å°¾ç«¯é€£çºŒåŠ æ¬Š tail=1 for i in range(n-2,-1,-1): if seq[i]==seq[-1]: tail+=1 else: break if seq[-1] in {"B","P"}: boost = min(0.10, 0.03*(tail-1)) if seq[-1]=="B": pb+=boost else: pp+=boost s=pb+pp+pt if s<=0: return {"banker":0.34,"player":0.34,"tie":0.32} return {"banker":round(pb/s,4),"player":round(pp/s,4),"tie":round(pt/s,4)} def betting_plan(pb: float, pp: float) -> Dict[str, Any]: diff = abs(pb-pp) side = "èŠ" if pb >= pp else "é–’" side_prob = max(pb, pp) if diff < 0.05: return {"side": side, "percent": 0.0, "side_prob": side_prob, "note": "å·®è·ä¸è¶³ 5%ï¼Œé¢¨éšªé«˜"} if diff < 0.08: pct = 0.02 elif diff < 0.12: pct = 0.04 elif diff < 0.18: pct = 0.08 else: pct = 0.12 return {"side": side, "percent": pct, "side_prob": side_prob} def render_reply(seq: List[str], probs: Dict[str,float], by_model: bool) -> str: b, p, t = probs["banker"], probs["player"], probs["tie"] plan = betting_plan(b, p) tag = "ï¼ˆæ¨¡å‹ï¼‰" if by_model else "ï¼ˆè¦å‰‡ï¼‰" win_txt = f"{plan['side_prob']*100:.1f}%" note = f"ï½œ{plan['note']}" if plan.get("note") else "" bet_text = "è§€æœ›" if plan["percent"] == 0 else f"ä¸‹ {plan['percent']*100:.0f}% æ–¼ã€Œ{plan['side']}ã€" return ( f"{tag} å·²è§£æ {len(seq)} æ‰‹\n" f"å»ºè­°ä¸‹æ³¨ï¼š{plan['side']}ï¼ˆå‹ç‡ {win_txt}ï¼‰{note}\n" f"æ©Ÿç‡ï¼šèŠ {b:.2f}ï½œé–’ {p:.2f}ï½œå’Œ {t:.2f}\n" f"è³‡é‡‘å»ºè­°ï¼š{bet_text}" ) # ========================================================= # APIï¼ˆå¯è‡ªæ¸¬ï¼‰ # ========================================================= @app.route("/") def index(): return "BGS AI åŠ©æ‰‹æ­£åœ¨é‹è¡Œ âœ… /line-webhook å·²å°±ç·’", 200 @app.route("/health") def health(): return jsonify({"status":"ok","ts":int(time.time()), "models_loaded": model_bundle.get("loaded", False), "note": model_bundle.get("note","")}) # ========================================================= # LINE Webhook # ========================================================= @app.route("/line-webhook", methods=['POST']) def line_webhook(): if not (line_bot_api and line_handler): logger.error("LINE creds missing: ACCESS_TOKEN or SECRET not set") abort(403) signature = request.headers.get('X-Line-Signature', '') body = request.get_data(as_text=True) logger.info(f"/line-webhook called, sig_len={len(signature)}, body_len={len(body)}") try: line_handler.handle(body, signature) except InvalidSignatureError as e: logger.exception(f"InvalidSignatureError: {e}. " f"==> é€šå¸¸æ˜¯ LINE_CHANNEL_SECRET ä¸å° æˆ– ç”¨éŒ¯ Channel çš„ Secret/Token") return "Invalid signature", 200 except Exception as e: logger.exception(f"Unhandled error while handling webhook: {e}") return "Error", 200 return "OK" if line_handler and line_bot_api: @line_handler.add(FollowEvent) def on_follow(event: FollowEvent): welcome = ( "æ­¡è¿åŠ å…¥BGS AI åŠ©æ‰‹ ğŸ‰\n\n" "è¼¸å…¥ã€Œé–‹å§‹åˆ†æã€å¾Œï¼Œä¸Šå‚³ç‰Œè·¯æˆªåœ–ï¼Œæˆ‘æœƒè‡ªå‹•è¾¨è­˜ä¸¦å›å‚³å»ºè­°ä¸‹æ³¨ï¼šèŠ / é–’ï¼ˆå‹ç‡ xx%ï¼‰ã€‚" ) line_bot_api.reply_message(event.reply_token, TextSendMessage(text=welcome)) @line_handler.add(MessageEvent, message=TextMessage) def on_text(event: MessageEvent): uid = getattr(event.source, "user_id", "unknown") txt = (event.message.text or "").strip() if txt in {"é–‹å§‹åˆ†æ", "é–‹å§‹", "START", "åˆ†æ"}: user_mode[uid] = True msg = "å·²é€²å…¥åˆ†ææ¨¡å¼ âœ…\nè«‹ä¸Šå‚³ç‰Œè·¯æˆªåœ–ï¼šæˆ‘æœƒå˜—è©¦è‡ªå‹•è¾¨è­˜ä¸¦å›è¦†ã€Œå»ºè­°ä¸‹æ³¨ï¼šèŠ / é–’ï¼ˆå‹ç‡ xx%ï¼‰ã€" line_bot_api.reply_message(event.reply_token, TextSendMessage(text=msg)) return # éã€Œé–‹å§‹åˆ†æã€æŒ‡ä»¤ line_bot_api.reply_message(event.reply_token, TextSendMessage( text="è«‹å…ˆè¼¸å…¥ã€Œé–‹å§‹åˆ†æã€ï¼Œå†ä¸Šå‚³ç‰Œè·¯æˆªåœ–ã€‚" )) @line_handler.add(MessageEvent, message=ImageMessage) def on_image(event: MessageEvent): uid = getattr(event.source, "user_id", "unknown") if not user_mode.get(uid): line_bot_api.reply_message(event.reply_token, TextSendMessage( text="å°šæœªå•Ÿç”¨åˆ†ææ¨¡å¼ã€‚\nè«‹å…ˆè¼¸å…¥ã€Œé–‹å§‹åˆ†æã€ï¼Œå†ä¸Šå‚³ç‰Œè·¯æˆªåœ–ã€‚" )) return # ä¸‹è¼‰åœ–ç‰‡ â†’ è§£æåºåˆ— â†’ æ¨ç† â†’ å›è¦† content = line_bot_api.get_message_content(event.message.id) img_bytes = b"".join(chunk for chunk in content.iter_content()) seq = extract_sequence_from_image(img_bytes) if not seq: tip = ( "è¾¨è­˜å¤±æ•— ğŸ˜¥\n" "è«‹ç¢ºä¿æˆªåœ–æ¸…æ¥šåŒ…å«å¤§è·¯ï¼Œä¸¦é¿å…éåº¦ç¸®æ”¾æˆ–æ¨¡ç³Šã€‚" ) line_bot_api.reply_message(event.reply_token, TextSendMessage(text=tip)); return if model_bundle.get("loaded"): probs = predict_with_models(seq); by_model = probs is not None if not by_model: probs = predict_probs_from_seq_rule(seq) else: probs = predict_probs_from_seq_rule(seq); by_model = False msg = render_reply(seq, probs, by_model) line_bot_api.reply_message(event.reply_token, TextSendMessage(text=msg)) if __name__ == "__main__": port = int(os.getenv("PORT", "5000")) app.run(host="0.0.0.0", port=port)
